<!DOCTYPE rpsl_syntax SYSTEM "syntax.dtd">

<!-- 

file: syntax.xml

description: Defines the various syntaxes that RPSL attributes can have.

$Id: syntax.xml,v 1.35 2007/02/21 15:47:00 agoston Exp $

-->

<rpsl_syntax>

   <attribute_syntax name="filter-set">
      <core>
          <regex>
              ^.{1,80}$
          </regex>
       </core>
       <front_end>
          <regex>
              ^((AS(0|[1-9][0-9]{0,8}|[1-3][0-9]{9}|4[01][0-9]{8}|42[0-8][0-9]{7}|429[0-3][0-9]{6}|4294[0-8][0-9]{5}|42949[0-5][0-9]{4}|429496[0-6][0-9]{3}|4294967[01][0-9]{2}|42949672[0-8][0-9]{1}|429496729[0-5])|fltr-[A-Z0-9_-]*[A-Z0-9]):)*fltr-[A-Z0-9_-]*[A-Z0-9](:(AS(0|[1-9][0-9]{0,8}|[1-3][0-9]{9}|4[01][0-9]{8}|42[0-8][0-9]{7}|429[0-3][0-9]{6}|4294[0-8][0-9]{5}|42949[0-5][0-9]{4}|429496[0-6][0-9]{3}|4294967[01][0-9]{2}|42949672[0-8][0-9]{1}|429496729[0-5])|fltr-[A-Z0-9_-]*[A-Z0-9]))*$
          </regex>
       </front_end>
       <description>
     A filter-set name is made up of letters, digits, the
     character underscore "_", and the character hyphen "-"; it
     must start with "fltr-", and the last character of a name
     must be a letter or a digit.

     A filter-set name can also be hierarchical.  A hierarchical
     set name is a sequence of set names and AS numbers separated
     by colons ":".  At least one component of such a name must
     be an actual set name (i.e. start with "fltr-").  All the
     set name components of a hierarchical filter-name have to be
     filter-set names.
       </description>
   </attribute_syntax>

   <attribute_syntax name="irt">
      <core>
          <regex>
              ^.{1,80}$
          </regex>
       </core>
       <front_end>
          <regex>
              ^irt-[A-Z0-9_-]*[A-Z0-9]$
          </regex>
       </front_end>
       <description>
     An irt name is made up of letters, digits, the character
     underscore "_", and the character hyphen "-"; it must start
     with "irt-", and the last character of a name must be a
     letter or a digit.
       </description>
   </attribute_syntax>

   <attribute_syntax name="as-set">
       <core>
          <regex>
              ^.{1,80}$
          </regex>
       </core>
       <front_end>
           <regex>
              ^((AS(0|[1-9][0-9]{0,8}|[1-3][0-9]{9}|4[01][0-9]{8}|42[0-8][0-9]{7}|429[0-3][0-9]{6}|4294[0-8][0-9]{5}|42949[0-5][0-9]{4}|429496[0-6][0-9]{3}|4294967[01][0-9]{2}|42949672[0-8][0-9]{1}|429496729[0-5])|as-[A-Z0-9_-]*[A-Z0-9]):)*as-[A-Z0-9_-]*[A-Z0-9](:(AS(0|[1-9][0-9]{0,8}|[1-3][0-9]{9}|4[01][0-9]{8}|42[0-8][0-9]{7}|429[0-3][0-9]{6}|4294[0-8][0-9]{5}|42949[0-5][0-9]{4}|429496[0-6][0-9]{3}|4294967[01][0-9]{2}|42949672[0-8][0-9]{1}|429496729[0-5])|as-[A-Z0-9_-]*[A-Z0-9]))*$
           </regex>
       </front_end>
       <description>
     An as-set name is made up of letters, digits, the
     character underscore "_", and the character hyphen "-"; it
     must start with "as-", and the last character of a name must
     be a letter or a digit.

     An as-set name can also be hierarchical.  A hierarchical set
     name is a sequence of set names and AS numbers separated by
     colons ":".  At least one component of such a name must be
     an actual set name (i.e. start with "as-").  All the set
     name components of a hierarchical as-name have to be as-set
     names.
       </description>
   </attribute_syntax>

   <attribute_syntax name="route-set">
       <core>
          <regex>
              ^.{1,80}$
          </regex>
       </core>
       <front_end>
           <regex>
              ^((AS(0|[1-9][0-9]{0,8}|[1-3][0-9]{9}|4[01][0-9]{8}|42[0-8][0-9]{7}|429[0-3][0-9]{6}|4294[0-8][0-9]{5}|42949[0-5][0-9]{4}|429496[0-6][0-9]{3}|4294967[01][0-9]{2}|42949672[0-8][0-9]{1}|429496729[0-5])|rs-[A-Z0-9_-]*[A-Z0-9]):)*rs-[A-Z0-9_-]*[A-Z0-9](:(AS(0|[1-9][0-9]{0,8}|[1-3][0-9]{9}|4[01][0-9]{8}|42[0-8][0-9]{7}|429[0-3][0-9]{6}|4294[0-8][0-9]{5}|42949[0-5][0-9]{4}|429496[0-6][0-9]{3}|4294967[01][0-9]{2}|42949672[0-8][0-9]{1}|429496729[0-5])|rs-[A-Z0-9_-]*[A-Z0-9]))*$
           </regex>
       </front_end>
       <description>
     An route-set name is made up of letters, digits, the
     character underscore "_", and the character hyphen "-"; it
     must start with "rs-", and the last character of a name must
     be a letter or a digit.

     A route-set name can also be hierarchical.  A hierarchical
     set name is a sequence of set names and AS numbers separated
     by colons ":".  At least one component of such a name must
     be an actual set name (i.e. start with "rs-").  All the set
     name components of a hierarchical route-name have to be
     route-set names.
       </description>
   </attribute_syntax>

   <attribute_syntax name="peering-set">
      <core>
          <regex>
              ^.{1,80}$
          </regex>
       </core>
       <front_end>
          <regex>
              ^((AS(0|[1-9][0-9]{0,8}|[1-3][0-9]{9}|4[01][0-9]{8}|42[0-8][0-9]{7}|429[0-3][0-9]{6}|4294[0-8][0-9]{5}|42949[0-5][0-9]{4}|429496[0-6][0-9]{3}|4294967[01][0-9]{2}|42949672[0-8][0-9]{1}|429496729[0-5])|prng-[A-Z0-9_-]*[A-Z0-9]):)*prng-[A-Z0-9_-]*[A-Z0-9](:(AS(0|[1-9][0-9]{0,8}|[1-3][0-9]{9}|4[01][0-9]{8}|42[0-8][0-9]{7}|429[0-3][0-9]{6}|4294[0-8][0-9]{5}|42949[0-5][0-9]{4}|429496[0-6][0-9]{3}|4294967[01][0-9]{2}|42949672[0-8][0-9]{1}|429496729[0-5])|prng-[A-Z0-9_-]*[A-Z0-9]))*$
          </regex>
       </front_end>
       <description>
     A peering-set name is made up of letters, digits, the
     character underscore "_", and the character hyphen "-"; it
     must start with "prng-", and the last character of a name
     must be a letter or a digit.

     A peering-set name can also be hierarchical.  A hierarchical
     set name is a sequence of set names and AS numbers separated
     by colons ":".  At least one component of such a name must
     be an actual set name (i.e. start with "prng-").  All the
     set name components of a hierarchical peering-set name have
     to be peering-set names.
       </description>
   </attribute_syntax>

   <attribute_syntax name="rtr-set">
      <core>
          <regex>
              ^.{1,80}$
          </regex>
       </core>
       <front_end>
          <regex>
              ^((AS(0|[1-9][0-9]{0,8}|[1-3][0-9]{9}|4[01][0-9]{8}|42[0-8][0-9]{7}|429[0-3][0-9]{6}|4294[0-8][0-9]{5}|42949[0-5][0-9]{4}|429496[0-6][0-9]{3}|4294967[01][0-9]{2}|42949672[0-8][0-9]{1}|429496729[0-5])|rtrs-[A-Z0-9_-]*[A-Z0-9]):)*rtrs-[A-Z0-9_-]*[A-Z0-9](:(AS(0|[1-9][0-9]{0,8}|[1-3][0-9]{9}|4[01][0-9]{8}|42[0-8][0-9]{7}|429[0-3][0-9]{6}|4294[0-8][0-9]{5}|42949[0-5][0-9]{4}|429496[0-6][0-9]{3}|4294967[01][0-9]{2}|42949672[0-8][0-9]{1}|429496729[0-5])|rtrs-[A-Z0-9_-]*[A-Z0-9]))*$
          </regex>
       </front_end>
       <description>
     A router-set name is made up of letters, digits, the
     character underscore "_", and the character hyphen "-"; it
     must start with "rtrs-", and the last character of a name
     must be a letter or a digit.

     A router-set name can also be hierarchical.  A hierarchical
     set name is a sequence of set names and AS numbers separated
     by colons ":".  At least one component of such a name must
     be an actual set name (i.e. start with "rtrs-").  All the
     set name components of a hierarchical router-set name have
     to be router-set names.
       </description>
   </attribute_syntax>

   <attribute_syntax name="members-as">
       <front_end>
          <regex>
              ^((((AS(0|[1-9][0-9]{0,8}|[1-3][0-9]{9}|4[01][0-9]{8}|42[0-8][0-9]{7}|429[0-3][0-9]{6}|4294[0-8][0-9]{5}|42949[0-5][0-9]{4}|429496[0-6][0-9]{3}|4294967[01][0-9]{2}|42949672[0-8][0-9]{1}|429496729[0-5])|as-[A-Z0-9_-]*[A-Z0-9]):)*as-[A-Z0-9_-]*[A-Z0-9](:(AS(0|[1-9][0-9]{0,8}|[1-3][0-9]{9}|4[01][0-9]{8}|42[0-8][0-9]{7}|429[0-3][0-9]{6}|4294[0-8][0-9]{5}|42949[0-5][0-9]{4}|429496[0-6][0-9]{3}|4294967[01][0-9]{2}|42949672[0-8][0-9]{1}|429496729[0-5])|as-[A-Z0-9_-]*[A-Z0-9]))*)|AS(0|[1-9][0-9]{0,8}|[1-3][0-9]{9}|4[01][0-9]{8}|42[0-8][0-9]{7}|429[0-3][0-9]{6}|4294[0-8][0-9]{5}|42949[0-5][0-9]{4}|429496[0-6][0-9]{3}|4294967[01][0-9]{2}|42949672[0-8][0-9]{1}|429496729[0-5]))$
          </regex>
       </front_end>
       <description>
     &lt;as-number&gt; or
     &lt;as-set-name&gt;
       </description>
   </attribute_syntax>

   <attribute_syntax name="members-is">
       <front_end>
           <parser_name>members_is</parser_name>
       </front_end>
       <description>
     &lt;inet-rtr-name&gt; or
     &lt;rtr-set-name&gt; or
     &lt;ipv4-address&gt;
       </description>
   </attribute_syntax>

   <attribute_syntax name="mp-members-is">
       <front_end>
           <parser_name>mp_members_is</parser_name>
       </front_end>
       <description>
     list of
     &lt;inet-rtr-name&gt; or
     &lt;rtr-set-name&gt; or
     &lt;ipv4-address&gt; or
     &lt;ipv6-address&gt;
       </description>
   </attribute_syntax>

   <attribute_syntax name="members-rs">
       <front_end>
          <parser_name>members_rs</parser_name>
       </front_end>
       <description>
     &lt;address-prefix-range&gt; or
     &lt;route-set-name&gt; or
     &lt;route-set-name&gt;&lt;range-operator&gt;.
       </description>
   </attribute_syntax>

   <attribute_syntax name="mp-members-rs">
       <front_end>
          <parser_name>mp_members_rs</parser_name>
       </front_end>
       <description>
     list of &lt;address-prefix-range&gt; or
     &lt;route-set-name&gt; or
     &lt;route-set-name&gt;&lt;range-operator&gt;.
       </description>
   </attribute_syntax>

   <attribute_syntax name="mbrs-by-ref">
       <core>
          <regex>
              ^.{1,80}$
          </regex>
       </core>
       <front_end>
           <regex>
               ^[A-Z]([A-Z0-9_-]*[A-Z0-9])?$
           </regex>
           <!-- note that ANY is not reserved for mbrs-by-ref -->
           <reserved_regex>
               ^(as-any|rs-any|peeras|and|or|not|atomic|from|to|at|action|accept|announce|except|refine|networks|into|inbound|outbound|rs-.*|rtrs-.*|fltr-.*|prng-.*)$
           </reserved_regex>
       </front_end>
       <description>
     &lt;mntner-name&gt; | ANY 
       </description>
   </attribute_syntax>
   
   <attribute_syntax name="free-form">
       <description>
     A sequence of ASCII characters.
       </description>
   </attribute_syntax>

   <attribute_syntax name="non-core">
       <description></description>
       <core>
          <!-- disallow use of this attribute in the core -->
          <!-- since leading/trailing whitespace is removed before a check,
               this will always fail -->
          <regex>^[[:space:]]not possible[[:space:]]$</regex>
       </core>
       <front_end>
          <!-- we need to have a regex otherwise the core one will be 
               used -->
          <regex>.?</regex>
       </front_end>
   </attribute_syntax>
   
   <attribute_syntax name="nic-handle">
       <core>
          <regex>
            ^.{1,30}$
          </regex>
       </core>
       <front_end>
          <regex>
             ^(([A-Z]{2,4}([1-9][0-9]{0,5})?(-[A-Z]([A-Z0-9_-]{0,7}[A-Z0-9]))?)|(AUTO-[0-9]+([A-Z]{2,4})?))$
          </regex>
          <!-- disallow improperly formatted AUTO nic-handles -->
          <reserved_regex>
             ^AUTO-[^1-9]
          </reserved_regex>
       </front_end>
       <description>
     From 2 to 4 characters optionally followed by up to 5 digits
     optionally followed by a source specification.  The first digit
     must not be "0".  Source specification starts with "-" followed
     by source name up to 9-character length.
       </description>
   </attribute_syntax>

   <attribute_syntax name="organisation">
       <core>
          <regex>
            ^.{1,30}$
          </regex>
       </core>
       <front_end>
          <regex>
             ^(ORG-([A-Z]{2,4}([1-9][0-9]{0,5})?(-[A-Z]([A-Z0-9_-]{0,7}[A-Z0-9])))|(AUTO-[0-9]+([A-Z]{2,4})?))$
          </regex>
          <!-- disallow improperly formatted AUTO organisation IDs -->
          <reserved_regex>
             ^AUTO-[^1-9]
          </reserved_regex>
       </front_end>
       <description>
     The 'ORG-' string followed by 2 to 4 characters, followed by up to 5 digits
     followed by a source specification.  The first digit must not be "0".  
     Source specification starts with "-" followed by source name up to 
     9-character length.
       </description>
   </attribute_syntax>


   
   <attribute_syntax name="object-name">
      <core>
          <regex>
              ^.{1,80}$
          </regex>
      </core>    
      <front_end>
           <regex>
               ^[A-Z]([A-Z0-9_-]*[A-Z0-9])?$
           </regex>
           <reserved_regex>
               ^(any|as-any|rs-any|peeras|and|or|not|atomic|from|to|at|action|accept|announce|except|refine|networks|into|inbound|outbound|as-.*|rs-.*|rtrs-.*|fltr-.*|prng-.*|irt-.*)$
           </reserved_regex>
       </front_end>
       <description>
     Made up of letters, digits, the character underscore "_",
     and the character hyphen "-"; the first character of a name
     must be a letter, and the last character of a name must be a
     letter or a digit.  The following words are reserved by
     RPSL, and they can not be used as names:
   
      any as-any rs-any peeras and or not atomic from to at
      action accept announce except refine networks into inbound
      outbound
   
     Names starting with certain prefixes are reserved for
     certain object types.  Names starting with "as-" are
     reserved for as set names.  Names starting with "rs-" are
     reserved for route set names.  Names starting with "rtrs-"
     are reserved for router set names. Names starting with
     "fltr-" are reserved for filter set names. Names starting
     with "prng-" are reserved for peering set names. Names
     starting with "irt-" are reserved for irt names.
       </description>
   </attribute_syntax>

   <attribute_syntax name="netname">
      <core>
          <regex>
              ^.{1,80}$
          </regex>
      </core>    
      <front_end>
           <regex>
               ^[A-Z]([A-Z0-9_-]*[A-Z0-9])?$
           </regex>
       </front_end>
       <description>
     Made up of letters, digits, the character underscore "_",
     and the character hyphen "-"; the first character of a name
     must be a letter, and the last character of a name must be a
     letter or a digit.
       </description>
   </attribute_syntax>
   
   <attribute_syntax name="e-mail">
       <core>
          <regex>
              ^.{1,80}$
          </regex>
       </core>   
       <front_end>
           <regex>
               ^((([A-Z0-9~#$%&amp;'*+=?^_`{|}~/-]+\.)*[A-Z0-9~#$%&amp;'*+=?^_`{|}~/-]+)|(&quot;[^&quot;@\\]+&quot;))@([A-Z0-9-]+(\.[A-Z0-9-]+)+)$
           </regex>
       </front_end>
       <description>
     An e-mail address as defined in RFC 2822.
       </description>
   </attribute_syntax>
   
   <!-- XXX:
      The changed attribute now treats the date as optional.  This
      should probably be modified so that dates are required, but
      only issue a warning.
     -->
   <attribute_syntax name="changed">
       <front_end>
           <regex>
               ^((([A-Z0-9~#$%&amp;'*+=?^_`{|}~/-]+\.)*[A-Z0-9~#$%&amp;'*+=?^_`{|}~/-]+)|(&quot;[^&quot;@\\]+&quot;))@([A-Z0-9-]+(\.[A-Z0-9-]+)+)( [0-9]{8})?$
           </regex>
       </front_end>
       <description>
     An e-mail address as defined in RFC 2822, followed by a date
     in the format YYYYMMDD.
       </description>
   </attribute_syntax>
   
   <attribute_syntax name="filter">
       <front_end>
         <parser_name>filter</parser_name>
       </front_end>
       <description>
     Logical expression which when applied to a set of routes
     returns a subset of these routes. Please refer to RFC 2622
     for more information.
       </description>
   </attribute_syntax>

   <attribute_syntax name="v6-filter">
       <front_end>
         <parser_name>v6_filter</parser_name>
       </front_end>
       <description>
     Logical expression which when applied to a set of routes
     returns a subset of these routes. Please refer to RFC 2622
     and RPSLng I-D for more information.
       </description>
   </attribute_syntax>

   <attribute_syntax name="mp-filter">
       <front_end>
         <parser_name>mp_filter</parser_name>
       </front_end>
       <description>
     Logical expression which when applied to a set of multiprotocol
     routes returns a subset of these routes. Please refer to RPSLng 
     Internet Draft for more information.
       </description>
   </attribute_syntax>

   <attribute_syntax name="registry-name">
       <front_end>
           <regex>
               ^[A-Z]([A-Z0-9_-]*[A-Z0-9])?$
           </regex>
       </front_end>
       <description>
     Made up of letters, digits, the character underscore "_",
     and the character hyphen "-"; the first character of a 
     registry name must be a letter, and the last character of a
     registry name must be a letter or a digit.
       </description>
   </attribute_syntax>

   <attribute_syntax name="domain-name">
       <core>
          <regex>
              ^.{1,254}$
          </regex>
       </core>   
       <front_end>
           <regex>
             ^[A-Z0-9]([-A-Z0-9]*[A-Z0-9])?(\.[A-Z0-9]([-A-Z0-9]*[A-Z0-9])?)*(\.)?$
           </regex>
       </front_end>
       <description>
     Domain name as specified in RFC 1034 (point 5.2.1.2) with or
     without trailing dot (".").  The total length should not exceed
     254 characters (octets).
       </description>
   </attribute_syntax>

   <attribute_syntax name="nameserver">
       <front_end>
           <parser_name>nserver</parser_name>
       </front_end>
       <description>
     Nameserver name as specified in RFC 1034 with or without
     trailing dot (".").  The total length should not exceed
     254 characters (octets).

     The nameserver name may be optionally followed by IPv4 address
     in decimal dotted quad form (e.g. 192.0.2.1) or IPv6 address
     in lowercase canonical form (Section 2.2.1, RFC 4291).

     The nameserver name may be followed by an IP address only when
     the name is inside of the domain being delegated.
       </description>
   </attribute_syntax>

   <!-- used in cases where we want any allowable character -->
   <attribute_syntax name="subdomain-name">
       <core>
          <regex>
              ^.{1,254}$
          </regex>
       </core>   
       <front_end>
           <regex>
             [A-Z0-9]([-A-Z0-9]*[A-Z0-9])?(\.[A-Z0-9]([-A-Z0-9]*[A-Z0-9])?)*(\.)?$
           </regex>
       </front_end>
       <description>
     Domain name as specified in RFC 1034 with or without
     trailing dot (".").  The total length should not exceed
     254 characters (octets).
       </description>
   </attribute_syntax>

   <attribute_syntax name="ipv4-address">
       <front_end>
           <regex>
           ^(([1-9]?[0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([1-9]?[0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$
           </regex>
       </front_end>
       <description>
     An IPv4 address is represented as a sequence of four
     integers in the range from 0 to 255 separated by the
     character dot (".").  For example, 128.9.128.5 represents a
     valid IPv4 address.
       </description>
   </attribute_syntax>

   <attribute_syntax name="refer">
       <core>
           <parser_name>refer</parser_name>
       </core>
       <description>
     &lt;type&gt; &lt;hostname&gt; [&lt;port&gt;]

     &lt;type&gt;  specifies the type of referral to be used.
     Supported types are SIMPLE, INTERNIC, RIPE, and
     CLIENTADDRESS.

     &lt;hostname&gt;  is the DNS name or &lt;ipv4 address&gt; of
     the referred host.

     &lt;port&gt;  is an integer specifying TCP port number at
     which queries are accepted by the referred host.  If
     &lt;port&gt; is omitted, the default number of 43 is used.
       </description>
   </attribute_syntax>

   <attribute_syntax name="person-name">
       <core>
          <regex>
          <!-- Not more than 10 words <64 char each --> 
          <!-- we allow \ in order to allow MySQL escaped strings to pass -->
              ^[A-Z0-9.\\`'_-]{1,64}( [A-Z0-9.\\`'_-]{1,64}){0,9}$
          </regex>
       </core>   
       <front_end>
           <regex>
               ^[A-Z]([A-Z0-9.`'_-]*[A-Z0-9`'_-])?([[:space:]]+[A-Z0-9.`'_-]+)*[[:space:]]+[A-Z]([A-Z0-9.`'_-]*[A-Z0-9`'_-])?$
           </regex>
           <reserved_regex>
               (^(Dr|Prof|Mv|Ms|Mr)\.?[[:space:]])|([[:space:]](Dr|Prof|Mv|Ms|Mr)\.?[[:space:]])
           </reserved_regex>
       </front_end>
       <description>
     A list of at least 2 words separated by white space. The
     first and the last word cannot end with dot ("."). The
     following words are not allowed: "Dr", "Prof", "Mv", "Ms",
     "Mr", no matter whether they end with dot (".") or not. A
     word is made up of letters, digits, the character underscore
     "_", and the character hyphen "-"; the first character of a
     name must be a letter, and the last character of a name must
     be a letter or a digit.
       </description>
   </attribute_syntax>

   <attribute_syntax name="org-name">
       <core>
          <regex>
          <!-- Not more than 12 words <64 char each --> 
            ^[][A-Z0-9._"*()@,&amp;:!'`+\/-]{1,64}( [][A-Z0-9._"*()@,&amp;:!'`+\/-]{1,64}){0,29}$
          </regex>
       </core>   
       <front_end>
           <regex>
           <!-- ^[][A-Z0-9"*().@]([][A-Z0-9._"*()@,&amp;:!'`+\/-]+)?([[:space:]]+[][A-Z0-9()&amp;@\/"',.:-]([][A-Z0-9._"*()@,&amp;:!'`+\/-]+)?)*$ -->
           <!-- same as backend -->
            ^[][A-Z0-9._"*()@,&amp;:!'`+\/-]{1,64}( [][A-Z0-9._"*()@,&amp;:!'`+\/-]{1,64}){0,29}$
           </regex>
       </front_end>
       <description>
     A list of words separated by white space.  A word is made up of letters,
     digits, the character underscore "_", and the character hyphen "-";
     the first character of a word must be a letter or digit; the last
     character of a word must be a letter, digit or a dot.
       </description>
   </attribute_syntax>

   <attribute_syntax name="org-type">
       <front_end>
           <regex>
           ^(IANA|RIR|NIR|LIR|WHITEPAGES|DIRECT_ASSIGNMENT|OTHER)$
           </regex>
       </front_end>
       <description>
     org-type can have one of these values:

     o IANA
     o RIR
     o NIR (There are no NIRs in the RIPE NCC service region.)
     o LIR
     o WHITEPAGES
     o DIRECT_ASSIGNMENT
     o OTHER
       </description>
   </attribute_syntax>


   <attribute_syntax name="telephone-number">
       <front_end>
           <regex>
               ^\+[[:space:]]*[0-9][0-9.[:space:]-]*(\([0-9.[:space:]-]*[0-9][0-9.[:space:]-]*\))?([0-9.[:space:]-]*[0-9][0-9.[:space:]-]*)?([[:space:]]+ext.[0-9.[:space:]-]*[0-9][0-9.[:space:]-]*)?$
           </regex>
       </front_end>
       <description>
     Contact telephone number. Can take one of the forms:

     '+' &lt;integer-list&gt;
     '+' &lt;integer-list&gt; "(" &lt;integer-list&gt; ")" &lt;integer-list&gt;
     '+' &lt;integer-list&gt; ext. &lt;integer list&gt;
     '+' &lt;integer-list&gt; "(" integer list ")" &lt;integer-list&gt; ext. &lt;integer-list&gt;
       </description>
   </attribute_syntax>

   <attribute_syntax name="auth-scheme">
       <core>
          <regex>^.{0,90}$</regex>
       </core>
       <front_end>
          <regex>
              ^(MD5-PW \$1\$[A-Z0-9./]{1,8}\$[A-Z0-9./]{22}|PGPKEY-[A-F0-9]{8}|X509-[1-9][0-9]*|AUTO-[1-9][0-9]*)$
          </regex>
       </front_end>
       <description>
&lt;auth-scheme&gt; &lt;scheme-info&gt;       Description

MD5-PW        encrypted           This scheme is the weakest form of 
              password, produced  authentication. It is by no means 
              using the FreeBSD   to keep out a determined malicious
              crypt_md5           attacker. As you are publishing the
              algorithm           encrypted password in the RIPE 
                                  database, it is open to attack.
                                  We strongly advise phrases longer 
                                  than 8 characters to be used,
                                  avoiding the use of words or
                                  combinations of words found in any
                                  dictionary of any language.

PGPKEY-&lt;id&gt;                       Strong scheme of authentication.
                                  &lt;id&gt; is the PGP key ID to be
                                  used for authentication. This string
                                  is the same one that is used in the
                                  corresponding key-cert object's
                                  "key-cert:" attribute.

X509-&lt;nnn&gt;                       Strong scheme of authentication.
                                  &lt;nnn&gt; is the index number of the
                                  corresponding key-cert object's
                                  "key-cert:" attribute (X509-nnn).
       </description>
   </attribute_syntax>

   <attribute_syntax name="inetnum">
       <core>
           <regex>
^((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])) - ((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))$
           </regex>
       </core>
       <front_end>
           <regex>
               ^((((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])) - ((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])))|(((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))/([89]|[12][0-9]|3[012])))$
           </regex>
       </front_end>
       <description>
     &lt;ipv4-address&gt; - &lt;ipv4-address&gt;
       </description>
   </attribute_syntax>

   <attribute_syntax name="inet6num">
       <front_end>
           <parser_name>inet6num</parser_name>
       </front_end>
       <description>
     &lt;ipv6-address&gt;/&lt;prefix&gt;
       </description>
   </attribute_syntax>

   <attribute_syntax name="country-code">
       <front_end>
           <regex>^[A-Z]{2}$</regex>
       </front_end>
       <description>
     Valid two-letter ISO 3166 country code.
       </description>
   </attribute_syntax>

   <attribute_syntax name="status-in">
       <front_end>
           <regex>
           ^((SUB-ALLOCATED PA)|NOT-SET|EARLY-REGISTRATION|ASSIGNED ANYCAST|((ALLOCATED (PA|PI|UNSPECIFIED))|((ASSIGNED|LIR-PARTITIONED) (PA|PI))))$
           </regex>
       </front_end>
       <description>
     Status can have one of these values:

     o ALLOCATED PA
     o ALLOCATED PI
     o ALLOCATED UNSPECIFIED
     o LIR-PARTITIONED PA
     o LIR-PARTITIONED PI
     o SUB-ALLOCATED PA
     o ASSIGNED PA
     o ASSIGNED PI
     o ASSIGNED ANYCAST
     o EARLY-REGISTRATION
     o NOT-SET
       </description>
   </attribute_syntax>

   <attribute_syntax name="status-i6">
       <front_end>
           <regex>
               ^(ALLOCATED-BY-RIR|ALLOCATED-BY-LIR|AGGREGATED-BY-LIR|ASSIGNED|ASSIGNED ANYCAST|ASSIGNED PI)$
           </regex>
       </front_end>
       <description>
     Status can have one of these values:

     o ALLOCATED-BY-RIR
     o ALLOCATED-BY-LIR
     o AGGREGATED-BY-LIR
     o ASSIGNED
     o ASSIGNED ANYCAST
     o ASSIGNED PI
       </description>
   </attribute_syntax>

   <attribute_syntax name="number">
       <core>
          <regex>
              ^[0-9]+$
          </regex>
       </core>
       <front_end>
           <regex>
               ^[0-9]+$
           </regex>
       </front_end>
       <description>
   Specifies a numeric value.
       </description>
   </attribute_syntax>

   <attribute_syntax name="mnt-routes">
       <core>
          <regex>
              ^[A-Z]([A-Z0-9_-]){1,80}([[:space:]]+.*)*$
          </regex>
       </core>   
       <front_end>
         <parser_name>mnt_routes</parser_name>
       </front_end>
         <!-- removed, we already check reserved words in mntner name
           <reserved_regex>
               ^(peeras|and|or|not|atomic|from|to|at|action|accept|announce|except|refine|networks|into|inbound|outbound|as-.*|rs-.*|rtrs-.*|fltr-.*|prng-.*|irt-.*)$
           </reserved_regex>
         -->
       <description>
     &lt;mnt-name&gt; [ { list of &lt;address-prefix-range&gt; } | ANY ]
       </description>
   </attribute_syntax>

   <attribute_syntax name="mnt-routes6">
       <core>
          <regex>
              ^[A-Z]([A-Z0-9_-]){1,80}([[:space:]]+.*)*$
          </regex>
       </core>
       <front_end>
         <!-- ANY allowed -->
         <parser_name>mnt_routes6</parser_name>
         <reserved_regex>
               ^(peeras|and|or|not|atomic|from|to|at|action|accept|announce|except|refine|networks|into|inbound|outbound|as-.*|rs-.*|rtrs-.*|fltr-.*|prng-.*|irt-.*)$
         </reserved_regex>
       </front_end>
       <description>
     &lt;mnt-name&gt; [ { list of &lt;ipv6-address&gt;/&lt;prefix&gt; } | ANY ]
       </description>
   </attribute_syntax>

   <attribute_syntax name="mnt-routes-an">
       <core>
          <regex>
              ^[A-Z]([A-Z0-9_-]){1,80}([[:space:]]+.*)*$
          </regex>
       </core>
       <front_end> 
         <!-- ANY allowed --> 
         <parser_name>mnt_routes_an</parser_name>
         <reserved_regex>
               ^(peeras|and|or|not|atomic|from|to|at|action|accept|announce|except|refine|networks|into|inbound|outbound|as-.*|rs-.*|rtrs-.*|fltr-.*|prng-.*|irt-.*)$
         </reserved_regex>
       </front_end>
       <description> 
     &lt;mnt-name&gt; [ { list of (&lt;ipv4-address&gt;/&lt;prefix&gt; or &lt;ipv6-address&gt;/&lt;prefix&gt;) } | ANY ]
       </description>
   </attribute_syntax>

   <attribute_syntax name="public-key">
       <!-- do we care what is in here? -->
       <description>
     The value of the public key should be supplied either using
     multiple "certif:" attributes, or in one "certif:"
     attribute. In the first case, this is easily done by
     exporting the key from your local key ring in ASCII armored
     format and prepending each line of the key with the string
     "certif:". In the second case, line continuation should be
     used to represent an ASCII armored format of the key. All
     the lines of the exported key must be included; also the
     begin and end markers and the empty line which separates the
     header from the key body.
       </description>
   </attribute_syntax>

   <attribute_syntax name="fingerpr">
       <front_end>
           <regex>
               ^(([A-F0-9]{4} ){9}[A-F0-9]{4})|(([A-F0-9]{2} ){15}[A-F0-9]{2})|(([A-F0-9]{2}:){15}[A-F0-9]{2})$
           </regex>
       </front_end>
       <description>
     Attribute generated by server.
       </description>
   </attribute_syntax>

   <attribute_syntax name="key-cert">
       <core>
         <regex>
               ^(PGPKEY-[A-F0-9]{8})|(X509-[1-9][0-9]*)|(X509-[*])$
          </regex>
       </core>   
       <front_end>
           <regex>
               ^(PGPKEY-[A-F0-9]{8})|(X509-[1-9][0-9]*)|(AUTO-[1-9][0-9]*)$
           </regex>
       </front_end>
       <description>
     PGPKEY-&lt;id&gt;

     &lt;id&gt; is  the PGP key ID of the public key in 8-digit
     hexadecimal format without "0x" prefix.
       </description>
   </attribute_syntax>

   <attribute_syntax name="method">
       <front_end>
           <regex>
               ^(PGP)|(X509)$
           </regex>
       </front_end>
       <description>
     Currently, only PGP keys are supported.
       </description>
   </attribute_syntax>

   <attribute_syntax name="address-prefix">
       <front_end>
           <regex>
^((([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))/([12]?[0-9]|3[012])$
           </regex>
       </front_end>
       <description>
     An address prefix is represented as an IPv4 address followed
     by the character slash "/" followed by an integer in the
     range from 0 to 32.  The following are valid address
     prefixes: 128.9.128.5/32, 128.9.0.0/16, 0.0.0.0/0; and the
     following address prefixes are invalid: 0/0, 128.9/16 since
     0 or 128.9 are not strings containing four integers.
       </description>
   </attribute_syntax>

   <attribute_syntax name="as-number">
       <core>
           <regex>^.{1,12}$</regex>
       </core>
       <front_end>
           <regex>
              ^AS(0|[1-9][0-9]{0,8}|[1-3][0-9]{9}|4[01][0-9]{8}|42[0-8][0-9]{7}|429[0-3][0-9]{6}|4294[0-8][0-9]{5}|42949[0-5][0-9]{4}|429496[0-6][0-9]{3}|4294967[01][0-9]{2}|42949672[0-8][0-9]{1}|429496729[0-5])$
           </regex>
       </front_end>
       <description>
     An "AS" string followed by an integer in the range
     from 0 to 4294967295
       </description>
   </attribute_syntax>

   <attribute_syntax name="as-block">
       <core>
           <regex>
              ^AS(0|[1-9][0-9]{0,8}|[1-3][0-9]{9}|4[01][0-9]{8}|42[0-8][0-9]{7}|429[0-3][0-9]{6}|4294[0-8][0-9]{5}|42949[0-5][0-9]{4}|429496[0-6][0-9]{3}|4294967[01][0-9]{2}|42949672[0-8][0-9]{1}|429496729[0-5]) - AS(0|[1-9][0-9]{0,8}|[1-3][0-9]{9}|4[01][0-9]{8}|42[0-8][0-9]{7}|429[0-3][0-9]{6}|4294[0-8][0-9]{5}|42949[0-5][0-9]{4}|429496[0-6][0-9]{3}|4294967[01][0-9]{2}|42949672[0-8][0-9]{1}|429496729[0-5])$
           </regex>
       </core>
       <description>
     &lt;as-number&gt; - &lt;as-number&gt;
       </description>
   </attribute_syntax>

   <attribute_syntax name="limerick">
      <core>
          <regex>
              ^.{1,80}$
          </regex>
       </core>
       <front_end>
          <regex>
              ^lim-[A-Z0-9_-]*$
          </regex>
       </front_end>
       <description>

       </description>
   </attribute_syntax>

   <attribute_syntax name="components">
       <front_end>
         <parser_name>components</parser_name>
       </front_end>
       <description>
     [ATOMIC] [[&lt;filter&gt;] [protocol &lt;protocol&gt; &lt;filter&gt; ...]]

     &lt;protocol&gt; is a routing routing protocol name such as
     BGP4, OSPF or RIP

     &lt;filter&gt; is a policy expression
       </description>
   </attribute_syntax>

   <attribute_syntax name="components-r6">
       <front_end>
         <parser_name>components_r6</parser_name>
       </front_end>
       <description>
     [ATOMIC] [[&lt;filter&gt;] [protocol &lt;protocol&gt; &lt;filter&gt; ...]]

     &lt;protocol&gt; is a routing routing protocol name such as
     BGP4, OSPF or RIP

     &lt;filter&gt; is a policy expression
       </description>
   </attribute_syntax>

   <attribute_syntax name="aggr-mtd">
       <front_end>
         <parser_name>aggr_mtd</parser_name>
       </front_end>
       <description>
     inbound | outbound [&lt;as-expression&gt;]
       </description>
   </attribute_syntax>

   <attribute_syntax name="aggr-bndry">
       <front_end>
         <parser_name>aggr_bndry</parser_name>
       </front_end>
       <description>
     [&lt;as-expression&gt;]
       </description>
   </attribute_syntax>

   <attribute_syntax name="default">
       <front_end>
         <parser_name>default</parser_name>
       </front_end>
       <description>
     to &lt;peering&gt; [action &lt;action&gt;] [networks &lt;filter&gt;]
       </description>
   </attribute_syntax>

   <attribute_syntax name="mp-default">
       <front_end>
         <parser_name>mp_default</parser_name>
       </front_end>
       <description>
     to &lt;peering&gt; [action &lt;action&gt;] [networks &lt;filter&gt;]
       </description>
   </attribute_syntax>

   <attribute_syntax name="export">
       <front_end>
         <parser_name>export</parser_name>
       </front_end>
       <description>
     [protocol &lt;protocol-1&gt;] [into &lt;protocol-1&gt;]
     to &lt;peering-1&gt; [action &lt;action-1&gt;] 
         .
         .
         .
     to &lt;peering-N&gt; [action &lt;action-N&gt;] 
     announce &lt;filter&gt;
       </description>
   </attribute_syntax>

   <attribute_syntax name="mp-export">
       <front_end>
         <parser_name>mp_export</parser_name>
       </front_end>
       <description>
     [protocol &lt;protocol-1&gt;] [into &lt;protocol-1&gt;]
     afi &lt;afi-list&gt;
     to &lt;peering-1&gt; [action &lt;action-1&gt;]
         .
         .
         .
     to &lt;peering-N&gt; [action &lt;action-N&gt;]
     announce &lt;filter&gt;
       </description>
   </attribute_syntax>

   <attribute_syntax name="import">
       <front_end>
         <parser_name>import</parser_name>
       </front_end>
       <description>
     [protocol &lt;protocol-1&gt;] [into &lt;protocol-1&gt;]
     from &lt;peering-1&gt; [action &lt;action-1&gt;] 
         .
         .
         .
     from &lt;peering-N&gt; [action &lt;action-N&gt;] 
     accept &lt;filter&gt;
       </description>
   </attribute_syntax>

   <attribute_syntax name="mp-import">
       <front_end>
         <parser_name>mp_import</parser_name>
       </front_end>
       <description>
     [protocol &lt;protocol-1&gt;] [into &lt;protocol-1&gt;]
     afi &lt;afi-list&gt;
     from &lt;peering-1&gt; [action &lt;action-1&gt;]
         .
         .
         .
     from &lt;peering-N&gt; [action &lt;action-N&gt;]
     accept (&lt;filter&gt;|&lt;filter&gt; except &lt;importexpression&gt;|
             &lt;filter&gt; refine &lt;importexpression&gt;)
       </description>
   </attribute_syntax>

   <attribute_syntax name="ifaddr">
       <core>
         <parser_name>ifaddr</parser_name>
       </core>
       <description>
     &lt;ipv4-address&gt; masklen &lt;integer&gt; [action &lt;action&gt;]
       </description>
   </attribute_syntax>

   <attribute_syntax name="interface">
       <core>
         <parser_name>interface</parser_name>
       </core>
       <description>
     afi &lt;afi&gt; &lt;ipv4-address&gt; masklen &lt;integer&gt; [action &lt;action&gt;]
     afi &lt;afi&gt; &lt;ipv6-address&gt; masklen &lt;integer&gt; [action &lt;action&gt;] 
               [tunnel &lt;remote-endpoint-address&gt;,&lt;encapsulation&gt;]
       </description>
   </attribute_syntax>

   <attribute_syntax name="inject">
       <front_end>
         <parser_name>inject</parser_name>
       </front_end>
       <description>
     [at &lt;router-expression&gt;]
     [action &lt;action&gt;]
     [upon &lt;condition&gt;]
       </description>
   </attribute_syntax>

   <attribute_syntax name="inject-r6">
       <front_end>
         <parser_name>inject_r6</parser_name>
       </front_end>
       <description>
     [at &lt;router-expression&gt;]
     [action &lt;action&gt;]
     [upon &lt;condition&gt;]
       </description>
   </attribute_syntax>

   <attribute_syntax name="peering">
       <front_end>
         <parser_name>peering</parser_name>
       </front_end>
       <description>
     &lt;peering&gt;
       </description>
   </attribute_syntax>

   <attribute_syntax name="mp-peering">
       <front_end>
         <parser_name>mp_peering</parser_name>
       </front_end>
       <description>
     afi &lt;afi&gt; &lt;peering&gt;
       </description>
   </attribute_syntax>

   <attribute_syntax name="peer">
       <front_end>
         <parser_name>peer</parser_name>
       </front_end>
       <description>
     &lt;protocol&gt; &lt;ipv4-address&gt; &lt;options&gt;
     | &lt;protocol&gt; &lt;inet-rtr-name&gt; &lt;options&gt;
     | &lt;protocol&gt; &lt;rtr-set-name&gt; &lt;options&gt;
     | &lt;protocol&gt; &lt;peering-set-name&gt; &lt;options&gt;
       </description>
   </attribute_syntax>

   <attribute_syntax name="mp-peer">
       <front_end>
         <parser_name>mp_peer</parser_name>
       </front_end>
       <description>
     &lt;protocol&gt; afi &lt;afi&gt; &lt;ipv4- or ipv6- address&gt; &lt;options&gt;
     | &lt;protocol&gt; &lt;inet-rtr-name&gt; &lt;options&gt;
     | &lt;protocol&gt; &lt;rtr-set-name&gt; &lt;options&gt;
     | &lt;protocol&gt; &lt;peering-set-name&gt; &lt;options&gt;
       </description>
   </attribute_syntax>

   <attribute_syntax name="referral-by">
      <front_end>
           <regex>
               ^RIPE-DBM-MNT$
           </regex>
       </front_end>
       <description>
     Only RIPE-DBM-MNT is allowed.
       </description>
   </attribute_syntax>

   <attribute_syntax name="poem">
      <core>
          <regex>
              ^.{1,80}$ 
          </regex>
       </core>
       <front_end>
          <regex>
              ^POEM-[A-Z0-9][A-Z0-9_-]*$
          </regex>
       </front_end>
       <description>
     POEM-&lt;string&gt;

     &lt;string&gt; can include alphanumeric characters, and "_" and 
     "-" characters.
       </description>
   </attribute_syntax>

   <attribute_syntax name="poetic-form">
      <core>
          <regex>
              ^.{1,80}$
          </regex>
       </core>
       <front_end>
          <regex>
              ^FORM-[A-Z0-9][A-Z0-9_-]*$
          </regex>
       </front_end>
       <description>
     FORM-&lt;string&gt;

     &lt;string&gt; can include alphanumeric characters, and "_" and
     "-" characters.
       </description>
   </attribute_syntax>

   <attribute_syntax name="ds-rdata">
      <core>
          <regex>
              ^.{1,255}$
          </regex>
       </core>
       <front_end>
          <regex>
            <!--  ^([1-9][0-9]{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-4])( ([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])){2} [ 0-9a-z]{1,64}([ ]*;.*)?$
            -->
            ^([1-9][0-9]{0,3}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-4])( ([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5]))( ([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])|RSAMD5|DH|DSA|ECC|RSASHA1|INDIRECT|PRIVATEDNS|PRIVATEOID)([ 0-9a-fA-F]{1,128})$
          </regex>
       </front_end>
       <description>
     &lt;Keytag&gt; | &lt;Algorithm&gt; | &lt;Digest type&gt; | &lt;Digest&gt; | ; &lt;Comment&gt; 

     Keytag is represented by an unsigned decimal integer (0-65535).

     Algorithm is represented by an unsigned decimal integer (0-255) or one of the following mnemonics:
     RSAMD5, DH, DSA, ECC, RSASHA1, INDIRECT, PRIVATEDNS, PRIVATEOID.

     Digest type may be represented by a unsigned decimal integer (0-255) and is usually 1, which stands for SHA-1.
 
     Digest is a digest in hexadecimal representation (case insensitive). Its length varies for various digest types. 
     For digest type SHA-1 digest is represented by 20 octets (40 characters, plus possible spaces).
     
     For more details, see RFC4034.
       </description>
   </attribute_syntax>

</rpsl_syntax>
